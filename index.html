<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BRADIPLOT — ECharts 3D (Time=X, MD=Y, Depth=Z)</title>
  <style>
    :root{--bg:#f6f8fa;--card:#fff;--muted:#6b7280;--accent:#2c7bb6}
    html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#111}
    .app{max-width:1200px;margin:12px auto;padding:12px;box-sizing:border-box}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
    h1{font-size:18px;margin:0}
    .top{display:flex;gap:12px;flex-wrap:wrap}
    .leftCard, .rightCard{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    .leftCard{flex:0 0 360px;min-width:220px}
    .rightCard{flex:1;min-width:260px;display:flex;flex-direction:column;align-items:flex-end}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    input[type="date"]{width:100%;padding:8px;border-radius:6px;border:1px solid #e6eef5;margin-bottom:10px;font-size:14px}
    .filters{width:100%;display:flex;flex-direction:column;gap:10px}
    .row{display:flex;align-items:center;gap:10px;width:100%}
    .row .name{min-width:56px;color:var(--muted);font-size:13px}
    .rangeInput{flex:1}
    .rangeValues{min-width:140px;text-align:right;font-size:13px;color:var(--muted)}
    .chartWrap{margin-top:12px;display:flex;gap:12px}
    #chartCard{flex:1;background:linear-gradient(#fff,#fbfdff);border-radius:10px;padding:10px;box-shadow:0 8px 20px rgba(0,0,0,0.06);min-height:520px;position:relative}
    #chart{width:100%;height:78vh;min-height:420px}
    .colorLegend{width:120px;display:flex;flex-direction:column;align-items:center;gap:8px}
    .colorTitle{font-size:13px;color:var(--muted);font-weight:600}
    .colorBarVisual{height:500px;width:30px;border-radius:6px;background:linear-gradient(#2c7bb6,#ffffbf,#d7191c);border:1px solid rgba(0,0,0,0.06)}
    .colorTicks{font-size:13px;color:var(--muted);display:flex;flex-direction:column;justify-content:space-between;height:500px}
    .stats{margin-top:12px;background:var(--card);padding:10px;border-radius:10px;display:flex;flex-wrap:wrap;gap:12px;box-shadow:0 6px 18px rgba(0,0,0,0.04)}
    .stat{font-size:14px;color:#222}

    /* time slider */
    .timeSliderWrap{
      position: relative;
      height: 60px;
      padding: 8px 0;
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      margin-bottom: 16px;
      user-select: none;
    }
    .timeRange{
      position: relative;
      width: 100%;
      height: 12px;
      border-radius: 6px;
      background: #e6eef5;
      cursor: grab;
      transition: background 0.3s ease;
      margin-top: 22px;
    }
    .timeRange:active{cursor:grabbing}

    /* native visible round handles (enabled) */
    input[type='range'].time{
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 12px;
      background: transparent;
      pointer-events: auto;
      -webkit-appearance: none;
      margin-top: 16px;
      z-index: 5;
    }
    input[type='range'].time::-webkit-slider-thumb{
      -webkit-appearance: none;
      width: 20px; height: 20px; border-radius: 50%;
      background: #2c7bb6; border: 2px solid #fff; box-shadow: 0 0 0 6px rgba(44,123,182,0.08);
      cursor: pointer; margin-top: -4px;
    }
    input[type='range'].time::-moz-range-thumb{
      width: 20px; height: 20px; border-radius: 50%; background: #2c7bb6; border: 2px solid #fff; cursor: pointer;
    }

    @media (max-width:880px){
      .top{flex-direction:column}
      .leftCard{width:100%}
      .rightCard{width:100%;align-items:stretch}
      .rangeValues{min-width:90px}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>BRADIPLOT — ECharts 3D (Time=X, MD=Y, Depth=Z)</h1>
      <div style="font-size:13px;color:var(--muted)">Terremoti del catalogo Gossip INGV-OV con MD&gt;0</div>
    </header>

    <div class="top">
      <div class="leftCard">
        <label>Selezione giorni inizio</label>
        <input id="dateMin" type="date">

        <label style="margin-top:8px">Selezione giorni fine</label>
        <input id="dateMax" type="date">
        <div style="font-size:13px;color:var(--muted);margin-top:6px">Giorni totali: <span id="totalDays">-</span></div>
      </div>

      <div class="rightCard">
        <div style="width:100%" class="filters">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong>Filtri</strong><span style="font-size:12px;color:var(--muted)">dinamici</span>
          </div>

          <div class="row" style="margin-top:6px">
            <div class="name">MD</div>
            <input id="mdMin" class="rangeInput" type="range" min="0" max="6" step="0.1" value="0">
            <input id="mdMax" class="rangeInput" type="range" min="0" max="6" step="0.1" value="6">
            <div class="rangeValues" id="mdValues">0 — 6</div>
          </div>

          <div class="row">
            <div class="name">Depth</div>
            <input id="depthMin" class="rangeInput" type="range" min="-10000" max="0" step="1" value="-5000">
            <input id="depthMax" class="rangeInput" type="range" min="-10000" max="0" step="1" value="0">
            <div class="rangeValues" id="depthValues">-5000 — 0 m</div>
          </div>

          <!-- Barra temporale -->
          <label style="margin-top:8px; display:block">Finestra temporale mobile</label>
          <div class="timeSliderWrap" id="timeSliderWrap">
            <div class="timeRange" id="timeRangeTrack"></div>

            <!-- two native range inputs with visible round thumbs -->
            <input id="timeWindowStart" class="time" type="range" step="1000" />
            <input id="timeWindowEnd" class="time" type="range" step="1000" />
          </div>

          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
            <div id="timeWindowStartLabel" style="font-size:13px;color:var(--muted)"></div>
            <div id="timeWindowEndLabel" style="font-size:13px;color:var(--muted)"></div>
          </div>

          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
            <label for="windowSize">Dimensione finestra (giorni):</label>
            <input id="windowSize" type="number" min="1" value="500" style="width:80px">
          </div>
        </div>
      </div>
    </div>

    <div class="chartWrap">
      <div id="chartCard"><div id="chart"></div></div>
      <div class="colorLegend">
        <div class="colorTitle">Depth=Z</div>
        <div style="display:flex;gap:8px;align-items:flex-start">
          <div class="colorBarVisual" id="colorBarVisual"></div>
          <div class="colorTicks" id="colorTicks">
            <div id="tickMax">0 m</div>
            <div id="tickMid">-</div>
            <div id="tickMin">- m</div>
          </div>
        </div>
      </div>
    </div>

    <div class="stats" id="stats" style="margin-top:10px">
      <div class="stat" id="totalCount">Totale terremoti filtrati: 0</div>
      <div class="stat" id="c1">MD ≥ 0 &lt; 1: 0</div>
      <div class="stat" id="c2">MD ≥ 1 &lt; 2: 0</div>
      <div class="stat" id="c3">MD ≥ 2 &lt; 3: 0</div>
      <div class="stat" id="c4">MD ≥ 3 &lt; 4: 0</div>
      <div class="stat" id="c5">MD ≥ 4: 0</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/echarts@6.0.0/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts-gl@2.0.9/dist/echarts-gl.min.js"></script>

  <script>
  // CONFIG
  const CSV_URL = 'https://marcscama.github.io/BradiPlot/Terremoti-Gossip.csv';

  // DOM
  const dateMinInput = document.getElementById('dateMin');
  const dateMaxInput = document.getElementById('dateMax');
  const totalDaysEl = document.getElementById('totalDays');
  const mdMinEl = document.getElementById('mdMin');
  const mdMaxEl = document.getElementById('mdMax');
  const depthMinEl = document.getElementById('depthMin');
  const depthMaxEl = document.getElementById('depthMax');
  const mdValues = document.getElementById('mdValues');
  const depthValues = document.getElementById('depthValues');
  const totalCount = document.getElementById('totalCount');
  const c1 = document.getElementById('c1');
  const c2 = document.getElementById('c2');
  const c3 = document.getElementById('c3');
  const c4 = document.getElementById('c4');
  const c5 = document.getElementById('c5');
  const chartEl = document.getElementById('chart');
  const tickMax = document.getElementById('tickMax');
  const tickMid = document.getElementById('tickMid');
  const tickMin = document.getElementById('tickMin');
  const timeWindowStart = document.getElementById('timeWindowStart');
  const timeWindowEnd = document.getElementById('timeWindowEnd');
  const timeRangeTrack = document.getElementById('timeRangeTrack');
  const timeSliderWrap = document.getElementById('timeSliderWrap');
  const timeWindowStartLabel = document.getElementById('timeWindowStartLabel');
  const timeWindowEndLabel = document.getElementById('timeWindowEndLabel');
  const windowSizeInput = document.getElementById('windowSize');

  // state
  let preprocessed = [];
  let filtered = [];
  let chart = null;
  let totalDays = 1;

  // Controls the minimum pixel width for comfortable dragging.
  // We'll compute the pixel width that corresponds to 1 day and always use:
  // minVisiblePx = Math.max(1day_px, MIN_TOUCH_PX)
  const MIN_TOUCH_PX = 36;

  function msPerDay(){ return 24*3600*1000; }

  // CSV helpers
  function parseCSV(text){
    const lines = text.split(/\r?\n/).filter(l=>l.trim());
    if(!lines.length) return [];
    const headers = lines.shift().split(',').map(h=>h.trim());
    return lines.map(line=>{
      const cols = line.split(',');
      const obj = {};
      headers.forEach((h,i)=> obj[h] = cols[i]!==undefined ? cols[i].trim() : '');
      return obj;
    });
  }
  function normalizeRow(row){
    let t = row.Time ? String(row.Time).trim() : '';
    t = t.replace(' ', 'T').replace(/\.(\d+)/,'');
    const d = new Date(t);
    let timeObj=null,timeMs=null;
    if(!isNaN(d.getTime())){ timeObj = new Date(Math.floor(d.getTime()/1000)*1000); timeMs = timeObj.getTime(); }
    const depthKm = Number(row.Depth);
    const depth_m = Number.isFinite(depthKm) ? -depthKm*1000 : NaN;
    return { MD: Number(row.MD), Depth_km: depthKm, Depth_m: depth_m, Time: timeObj, timeMs: timeMs };
  }

  function updateSliderTexts(){
    mdValues.textContent = `${mdMinEl.value} — ${mdMaxEl.value}`;
    depthValues.textContent = `${depthMinEl.value} — ${depthMaxEl.value} m`;
  }

  // Calculate totalDays inclusive using UTC-midnights to avoid timezone shifts
  function computeTotalDaysInclusive(tMinMs, tMaxMs){
    const d0 = new Date(tMinMs), d1 = new Date(tMaxMs);
    const d0UTCmid = Date.parse(new Date(Date.UTC(d0.getUTCFullYear(), d0.getUTCMonth(), d0.getUTCDate())).toISOString().slice(0,10) + 'T00:00:00Z');
    const d1UTCmid = Date.parse(new Date(Date.UTC(d1.getUTCFullYear(), d1.getUTCMonth(), d1.getUTCDate())).toISOString().slice(0,10) + 'T00:00:00Z');
    return Math.max(1, Math.floor((d1UTCmid - d0UTCmid)/msPerDay()) + 1);
  }

  // Update gradient and native thumbs positions.
  // Mapping rule used:
  //   desiredPct = (windowSize / totalDays) * 100  (linear)
  //   minPct = (1 / totalDays) * 100  (represents exactly 1 day)
  //   visual width in px = clamp(desiredPct/100*trackW, minVisiblePx)
  function updateThumbsAndTrack(){
    const min = Number(timeWindowStart.min), max = Number(timeWindowStart.max);
    if(!min || !max || max <= min){
      timeRangeTrack.style.background = '#e6eef5';
      return;
    }

    let s = Number(timeWindowStart.value), t = Number(timeWindowEnd.value);
    if(s > t) [s,t] = [t,s];

    const rect = timeRangeTrack.getBoundingClientRect();
    const trackW = rect.width || 400;

    // percent positions from logical inputs
    const p0 = ((s - min) / (max - min)) * 100;
    const p1 = ((t - min) / (max - min)) * 100;

    // compute desired pct from windowSizeInput relative to totalDays (linear mapping)
    const desiredDays = Math.max(1, Number(windowSizeInput.value) || 1);
    let desiredPct = totalDays > 0 ? (desiredDays / totalDays) * 100 : 100;
    desiredPct = Math.max(desiredPct, (1/totalDays) * 100); // ensure 1 day => at least 1-day-percent

    // compute min visible px corresponding to 1 day (1day_px) and ensure comfortable touch (MIN_TOUCH_PX)
    const oneDayPct = (1/totalDays) * 100;
    const oneDayPx = (oneDayPct/100) * trackW;
    const minVisiblePx = Math.max(oneDayPx, MIN_TOUCH_PX);

    // calculate display width in px and corresponding display percent
    let desiredPx = (desiredPct/100) * trackW;
    if(desiredPx < minVisiblePx) desiredPx = minVisiblePx;
    if(desiredPx > trackW) desiredPx = trackW;
    const displayPctWidth = (desiredPx / trackW) * 100;

    // center display band on logical center (so position reflects where logical window sits)
    const logicalCenter = (p0 + p1) / 2;
    let displayP0 = Math.max(0, logicalCenter - displayPctWidth/2);
    let displayP1 = Math.min(100, logicalCenter + displayPctWidth/2);
    if(displayP0 === 0) displayP1 = Math.min(100, displayPctWidth);
    if(displayP1 === 100) displayP0 = Math.max(0, 100 - displayPctWidth);

    timeRangeTrack.style.background = `linear-gradient(90deg,#e6eef5 ${displayP0}%, var(--accent) ${displayP0}%, var(--accent) ${displayP1}%, #e6eef5 ${displayP1}%)`;

    // store positions for drag detection
    timeRangeTrack._displayP0 = displayP0;
    timeRangeTrack._displayP1 = displayP1;
    timeRangeTrack._actualP0 = p0;
    timeRangeTrack._actualP1 = p1;
  }

  function updateTimeWindowLabels(){
    const a = Number(timeWindowStart.value), b = Number(timeWindowEnd.value);
    timeWindowStartLabel.textContent = a ? new Date(a).toISOString().slice(0,19).replace('T',' ') : '-';
    timeWindowEndLabel.textContent = b ? new Date(b).toISOString().slice(0,19).replace('T',' ') : '-';
  }

  // When the native thumbs move (keyboard or mouse), update logical window and keep windowSizeInput in sync.
  function handleNativeInputChange(e){
    const minVal = Number(timeWindowStart.min), maxVal = Number(timeWindowStart.max);
    let s = Number(timeWindowStart.value), t = Number(timeWindowEnd.value);
    if(s > t) [s,t] = [t,s];

    // compute logical window in days from underlying values
    const newWindowDays = Math.max(1, Math.round((t - s + 1) / msPerDay()));
    // sync windowSizeInput with the logical window
    windowSizeInput.value = newWindowDays;

    s = Math.max(minVal, Math.min(maxVal, s));
    t = Math.max(minVal, Math.min(maxVal, t));
    timeWindowStart.value = Math.round(s);
    timeWindowEnd.value = Math.round(t);

    updateThumbsAndTrack();
    updateTimeWindowLabels();
    applyFilters();
  }

  function applyFilters(){
    updateSliderTexts();
    updateTimeWindowLabels();
    updateThumbsAndTrack();

    let mdLo = +mdMinEl.value, mdHi = +mdMaxEl.value; if(mdLo > mdHi) [mdLo, mdHi] = [mdHi, mdLo];
    let dLo = +depthMinEl.value, dHi = +depthMaxEl.value; if(dLo > dHi) [dLo, dHi] = [dHi, dLo];

    let t0 = Number(timeWindowStart.value), t1 = Number(timeWindowEnd.value);
    if(t0 > t1) [t0,t1] = [t1,t0];

    filtered = preprocessed.filter(d => {
      if(d.MD < mdLo || d.MD > mdHi) return false;
      if(d.Depth_m < dLo || d.Depth_m > dHi) return false;
      if(d.timeMs < t0 || d.timeMs > t1) return false;
      return true;
    });

    updateStats();
    draw3D();
  }

  function updateStats(){
    totalCount.textContent = `Totale terremoti filtrati: ${filtered.length}`;
    c1.textContent = `MD ≥ 0 < 1: ${filtered.filter(d=>d.MD>=0 && d.MD<1).length}`;
    c2.textContent = `MD ≥ 1 < 2: ${filtered.filter(d=>d.MD>=1 && d.MD<2).length}`;
    c3.textContent = `MD ≥ 2 < 3: ${filtered.filter(d=>d.MD>=2 && d.MD<3).length}`;
    c4.textContent = `MD ≥ 3 < 4: ${filtered.filter(d=>d.MD>=3 && d.MD<4).length}`;
    c5.textContent = `MD ≥ 4: ${filtered.filter(d=>d.MD>=4).length}`;
  }

  function initChart(){ if(!chart) chart = echarts.init(chartEl); window.addEventListener('resize', ()=>{ chart && chart.resize(); updateThumbsAndTrack(); }); }

  function draw3D(){
    const dataForColor = filtered.length ? filtered : preprocessed; if(!dataForColor || !dataForColor.length){ chart.clear(); return; }
    const xArr = dataForColor.map(d=>d.timeMs);
    const yArr = dataForColor.map(d=>d.MD);
    const zArr = dataForColor.map(d=>d.Depth_m);
    const depthMin = Math.min(...zArr); const depthMax = Math.max(...zArr);
    const mdMin = Math.min(...yArr); const mdMax = Math.max(...yArr);
    tickMax.textContent = `${Math.round(depthMax)} m`; tickMin.textContent = `${Math.round(depthMin)} m`; tickMid.textContent = `${Math.round((depthMax + depthMin)/2)} m`;
    const seriesData = dataForColor.map(d => [d.timeMs, d.MD, d.Depth_m]);
    let xMin = Number(timeWindowStart.value), xMax = Number(timeWindowEnd.value); if(xMin > xMax) [xMin,xMax] = [xMax,xMin]; if(xMin === xMax){ xMin -= msPerDay(); xMax += msPerDay(); }

    const option = {
      tooltip:{ formatter: params => {
        const v = params.value || []; const timeStr = v[0] ? new Date(v[0]).toISOString().slice(0,19).replace('T',' ') : 'n/a';
        return `Time: ${timeStr}<br/>MD: ${v[1].toFixed(2)}<br/>Depth: ${Math.round(v[2])} m`;
      }},
      visualMap: [
        { type: 'continuous', dimension: 2, min: depthMin, max: depthMax, inRange: { color: ['#2c7bb6','#ffffbf','#d7191c'] }, orient: 'vertical', right: 20, top: 'center', itemHeight: 400, itemWidth: 20, text: ['Depth=Z',''], formatter: v => `${Math.round(v)} m` },
        { type: 'continuous', dimension: 1, min: mdMin, max: mdMax, inRange: { symbolSize: [4, 24] }, show: false }
      ],
      grid3D: { viewControl: { autoRotate: false, projection: 'perspective' }, boxWidth: '300' },
      xAxis3D: { name: 'Time', type: 'value', min: xMin, max: xMax, axisLabel: { formatter: val => val ? new Date(val).toISOString().slice(0,10) : '' } },
      yAxis3D: { name: 'MD', type: 'value', min: mdMin, max: mdMax },
      zAxis3D: { name: 'Depth (m)', type: 'value', min: depthMin, max: 0 },
      series: [{ type: 'scatter3D', data: seriesData, itemStyle: { borderWidth: 0.1 }, emphasis: { itemStyle: { borderWidth: 1 } } }]
    };
    chart.setOption(option, { notMerge: false });
  }

  // Dragging logic: click on center band to move window; native thumbs still work and are visible
  function setupTrackDrag(){
    let draggingCenter = false;
    let centerStartMouseX = 0;
    let centerInitialStart = 0, centerInitialEnd = 0;

    function clientXToValue(clientX){
      const rect = timeRangeTrack.getBoundingClientRect();
      const min = Number(timeWindowStart.min), max = Number(timeWindowStart.max);
      let x = Math.min(rect.right, Math.max(rect.left, clientX));
      const frac = (x - rect.left) / rect.width;
      return Math.round(min + frac * (max - min));
    }

    timeSliderWrap.addEventListener('mousedown', (e)=>{
      if(e.button !== 0) return;
      const rect = timeRangeTrack.getBoundingClientRect();
      const displayP0 = timeRangeTrack._displayP0 || 0;
      const displayP1 = timeRangeTrack._displayP1 || 100;
      const p0px = rect.left + (displayP0/100)*rect.width;
      const p1px = rect.left + (displayP1/100)*rect.width;
      const expand = Math.max(10, (MIN_TOUCH_PX - (p1px - p0px))/2);
      if(e.clientX >= p0px - expand && e.clientX <= p1px + expand){
        draggingCenter = true; centerStartMouseX = e.clientX; centerInitialStart = Number(timeWindowStart.value); centerInitialEnd = Number(timeWindowEnd.value);
        e.preventDefault();
      }
    }, true);

    document.addEventListener('mousemove', (e)=>{
      if(!draggingCenter) return;
      const rect = timeRangeTrack.getBoundingClientRect();
      const min = Number(timeWindowStart.min), max = Number(timeWindowStart.max);
      const deltaX = e.clientX - centerStartMouseX;
      const deltaTime = deltaX / rect.width * (max - min);
      let newStart = centerInitialStart + deltaTime;
      let newEnd = centerInitialEnd + deltaTime;
      if(newStart < min){ const diff = min - newStart; newStart += diff; newEnd += diff; }
      if(newEnd > max){ const diff = newEnd - max; newStart -= diff; newEnd -= diff; }
      timeWindowStart.value = Math.round(newStart);
      timeWindowEnd.value = Math.round(newEnd);
      updateThumbsAndTrack(); updateTimeWindowLabels();
    });

    document.addEventListener('mouseup', ()=>{
      if(draggingCenter){ draggingCenter = false; applyFilters(); }
    });

    // native inputs react to keyboard and mouse
    timeWindowStart.addEventListener('input', handleNativeInputChange);
    timeWindowEnd.addEventListener('input', handleNativeInputChange);
    timeWindowStart.addEventListener('change', handleNativeInputChange);
    timeWindowEnd.addEventListener('change', handleNativeInputChange);
  }

  async function loadData(){
    try{
      const resp = await fetch(CSV_URL);
      if(!resp.ok) throw new Error('HTTP ' + resp.status);
      const txt = await resp.text();
      const rows = parseCSV(txt);
      preprocessed = rows.map(normalizeRow).filter(r => Number.isFinite(r.MD) && Number.isFinite(r.Depth_m) && r.Time instanceof Date);
      if(!preprocessed.length) throw new Error('Nessun dato valido dopo preprocessing.');

      // MD sliders
      const mdVals = preprocessed.map(d=>d.MD);
      const mdMinVal = Math.floor(Math.min(...mdVals)||0), mdMaxVal = Math.ceil(Math.max(...mdVals)||6);
      mdMinEl.min = Math.max(0, mdMinVal-1); mdMinEl.max = mdMaxVal+1; mdMinEl.value = Math.max(0, mdMinVal-1);
      mdMaxEl.min = Math.max(0, mdMinVal-1); mdMaxEl.max = mdMaxVal+1; mdMaxEl.value = mdMaxVal+1;

      // Depth sliders
      const depthMeters = preprocessed.map(d=>d.Depth_m);
      const dataMin = Math.floor(Math.min(...depthMeters));
      const initMin = Math.max(-10000, Math.min(dataMin, -100));
      depthMinEl.min = -10000; depthMinEl.max = 0; depthMinEl.value = initMin;
      depthMaxEl.min = -10000; depthMaxEl.max = 0; depthMaxEl.value = 0;

      // date range
      const times = preprocessed.map(d=>d.timeMs).filter(Boolean);
      const tMin = Math.min(...times), tMax = Math.max(...times);
      const initialMinDate = new Date(tMin).toISOString().slice(0,10);
      const initialMaxDate = new Date(tMax).toISOString().slice(0,10);

      // totalDays inclusive (fixed logic using UTC midnights)
      totalDays = computeTotalDaysInclusive(tMin, tMax);
      totalDaysEl.textContent = `${totalDays}`;

      dateMinInput.value = initialMinDate; dateMaxInput.value = initialMaxDate;
      dateMinInput.min = initialMinDate; dateMaxInput.min = initialMinDate;
      dateMinInput.max = initialMaxDate; dateMaxInput.max = initialMaxDate;

      // set timeWindow inputs min/max (ms values)
      const minMs = Date.parse(initialMinDate + 'T00:00:00Z');
      const maxMs = Date.parse(initialMaxDate + 'T23:59:59Z');
      timeWindowStart.min = minMs; timeWindowStart.max = maxMs;
      timeWindowEnd.min = minMs; timeWindowEnd.max = maxMs;

      updateSliderTexts(); initChart(); setupTrackDrag();

      // initialize logical window based on selectors
      updateTimeRangeFromDateSelectors();
      applyFilters();
    } catch(err){
      console.error('Errore caricamento CSV', err);
      alert('Errore caricamento CSV: ' + (err.message||err));
    }
  }

  // update logical inputs when date selectors change
  function updateTimeRangeFromDateSelectors() {
    const minDate = Date.parse(dateMinInput.value + 'T00:00:00Z');
    const maxDate = Date.parse(dateMaxInput.value + 'T23:59:59Z');
    timeWindowStart.min = minDate; timeWindowStart.max = maxDate;
    timeWindowEnd.min = minDate; timeWindowEnd.max = maxDate;

    const desiredWindowDays = Math.max(1, Math.round(Number(windowSizeInput.value) || 1));
    const logicalWindowMs = Math.min(desiredWindowDays * msPerDay(), Math.max(1, maxDate - minDate));

    // default position: left-most
    let logicalStart = minDate;
    let logicalEnd = Math.min(maxDate, logicalStart + logicalWindowMs - 1000);

    if(logicalEnd - logicalStart < logicalWindowMs - 1000){
      logicalEnd = maxDate;
      logicalStart = Math.max(minDate, logicalEnd - logicalWindowMs + 1000);
    }

    timeWindowStart.value = Math.round(logicalStart);
    timeWindowEnd.value = Math.round(logicalEnd);

    updateThumbsAndTrack();
    updateTimeWindowLabels();
  }

  function attachEvents(){
    const inputs = [mdMinEl, mdMaxEl, depthMinEl, depthMaxEl];
    inputs.forEach(el => { el.addEventListener('input', applyFilters); el.addEventListener('change', applyFilters); });

    // native range thumbs
    timeWindowStart.addEventListener('input', handleNativeInputChange);
    timeWindowEnd.addEventListener('input', handleNativeInputChange);
    timeWindowStart.addEventListener('change', handleNativeInputChange);
    timeWindowEnd.addEventListener('change', handleNativeInputChange);

    // when user edits windowSize manually -> keep center and update logical window accordingly
    windowSizeInput.addEventListener('change', ()=>{
      let v = Math.max(1, Math.round(Number(windowSizeInput.value) || 1));
      windowSizeInput.value = v;
      const minVal = Number(timeWindowStart.min), maxVal = Number(timeWindowStart.max);
      const center = (Number(timeWindowStart.value) + Number(timeWindowEnd.value)) / 2;
      const targetWindowMs = Math.max(msPerDay(), v * msPerDay());
      let newStart = Math.max(minVal, Math.round(center - targetWindowMs/2));
      let newEnd = Math.min(maxVal, newStart + targetWindowMs - 1000);
      if(newEnd > maxVal){ newEnd = maxVal; newStart = Math.max(minVal, newEnd - targetWindowMs + 1000); }
      timeWindowStart.value = newStart; timeWindowEnd.value = newEnd;
      updateThumbsAndTrack(); updateTimeWindowLabels(); applyFilters();
    });

    dateMinInput.addEventListener('change', ()=>{ updateTimeRangeFromDateSelectors(); applyFilters(); });
    dateMaxInput.addEventListener('change', ()=>{ updateTimeRangeFromDateSelectors(); applyFilters(); });
  }

  // bootstrap
  (function bootstrap(){ attachEvents(); loadData(); })();
  </script>
</body>
</html>
